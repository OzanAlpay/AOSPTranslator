#!/usr/bin/env ruby
require 'nokogiri'
require 'axlsx'
require 'spreadsheet'
# author : Ozan Alpay
# email : ozanalpay at yandex dot com dot tr or ozan dot alpay at vestel dot com dot tr
# modification dates : [27/02/2017 , 28/02/2017, 01/03/2017, 03/03/2017] After that have started to use Git VCS
# company : Vestel Electronics


# This function find differences between two xml files string elements for ex:
# If values/strings.xml has 30 string,value keys whereas values-nl/strings.xml has only 15 -> That means you haven't translated 15 strings
# It will find them , at write their value to xls values according to their id , and value
# TODO Do Major refactoring here,
class Translator ## Like an abstract class
	attr_reader :input_language

	def initialize(input_language)
		@input_language = input_language
	end

	def prepare_english_docs(docs_list) ##Return available English Files Array
		file_names = docs_list.map{|doc| doc = 'values/' + doc}
		available_files = []
		file_names.each() do |file_name|
			begin
				current_file = Nokogiri::XML(File.open(file_name))
				available_files << current_file unless file_name.nil?
				puts "File = #{file_name} is added to available files for English lang"
			rescue
				puts "Cannot find #{file_name} for English language"
			end
		end
		available_files
	end

	def prepare_to_be_translated_lang_docs(docs_list) ##Iterate over all available files in selected language , find suitable items for selected type and save them into hash
		file_names = docs_list.map{|doc| doc = "values-#{@input_language}" + '/' + doc}
		available_files = []
		file_names.each() do |file_name|
			begin
				current_file = Nokogiri::XML(File.open(file_name))
				available_files << current_file unless file_name.nil?
				puts "File = #{file_name} is added to available files for #{@input_language} lang"
			rescue
				puts "Cannot find #{file_name} for #{@input_language}"
			end
		end
		available_files
	end

	def find_items_exist_in_to_be_translated_lang(input_lang_files, item_type)
		found_item_pairs = {}
		input_lang_files.each() do |input_lang_file|
			input_lang_file.xpath("//#{item_type}").each do |node|
				if TranslatorUtils.is_item_suitable_to_add_founded_list(node)
					found_item_pairs[node["name"]] = node.text
				end
			end
		end
		found_item_pairs
	end
=begin
	def is_item_suitable_to_add_founded_list(node)
		return ("false" != node["translatable"].to_s &&
					 "tablet" != node["product"] &&
					 !node.text.start_with?("@"))
	end
=end
	def find_missing_items(eng_docs, founded_items ,item_type)
		missing_item_pairs = {}
		eng_docs.each() do |doc|
			doc.xpath("//#{item_type}").each do |node|
				if TranslatorUtils.is_item_suitable_to_add_missing_list(node, founded_items, missing_item_pairs)
					#puts "#{node["name"]} : #{node.text} will be added, node.translatable is ->#{node["translatable"]}"
					#puts "#{node["name"]} : #{node.text} will be added, node.translatable is -> #{node["translatable"]}"
					missing_item_pairs[node["name"]] = node.text
				end
			end
		end
		missing_item_pairs
	end
=begin
	def is_item_suitable_to_add_missing_list(node, found_items, missing_item_pairs)
		 return ("false" != node["translatable"].to_s &&
							"tablet" != node["product"] &&
							!found_items.include?(node["name"]) &&
							!missing_item_pairs.include?(node["name"]) &&
							!node.text.start_with?('@'))
	end
=end
	def write_found_items_to_excel_file
		raise NotImplementedError
	end

	def translate
		write_found_items_to_excel_file
	end

	def import_translations_from_excel_file
		raise NotImplementedError
	end

	def transfer
		import_translations_from_excel_file
	end
end

class StringTranslator < Translator
	attr_reader :item_type, :docs
	def initialize(input_language)
		super(input_language)
		@item_type = "string"
		@docs = ["strings.xml", "cm_strings.xml", "qtistrings.xml"]
	end

	def prepare_english_docs ##Return available English Files Array
		super(@docs)
	end

	def prepare_to_be_translated_lang_docs ##Return array of available files , written in selected language
		super(@docs)
	end

	def find_items_exist_in_to_be_translated_lang##Iterate over all available files in selected language , find suitable items for selected type and save them into hash
		super(prepare_to_be_translated_lang_docs, @item_type)
	end

	def find_missing_items
		super(prepare_english_docs, find_items_exist_in_to_be_translated_lang ,@item_type)
	end

	def write_found_items_to_excel_file
		different_items = find_missing_items
		p = Axlsx::Package.new
		wb = p.workbook #Create excel sheet
		wb.add_worksheet(:name => "Basic Worksheet") do |sheet|
	   		sheet.add_row ["Id", "English", "#{@input_language.upcase}"]
	   			different_items.each do |key,value| #Write all key,value pairs one by one A column -> String, B column -> Value
	        		#print "Key is = #{key} , value is = #{value}"
							id = key
							englishVal = value
	   					sheet.add_row [id, englishVal]
	   		end
		end
		p.serialize("EnglishTo#{@input_language}translation#{@item_type}s.xls") #Have to save as xls , otherwise spreadsheet gem cannot read it correctly
		puts "EnglishTo#{@input_language}translation#{@item_type}s.xls created"
	end

	def import_found_items_from_excel_file
		puts  "transfer_string_translations started with = #{@input_language}"
		Spreadsheet.client_encoding = 'UTF-8'
		begin
			book = Spreadsheet.open("EnglishTo#{@input_language}translationstrings.xls")
			file_name = "values-#{@input_language}/strings.xml"
			#xml_file = Nokogiri::XML(File.open("values-#{input_language}/strings.xml")
			xml_file = File.read("values-#{@input_language}/strings.xml")
			doc = Nokogiri::XML(xml_file)
		rescue SystemCallError
			raise
		end

		#toBeInsertedStrings = {};
		sheet1 = book.worksheet 0
		sheet1.each 1 do |row|
			if row[2] != nil
				string_node = Nokogiri::XML::Node.new "#{@item_type}", doc
				puts string_node
				string_node.content = row[2]
				string_node["name"] = row[0]
				#puts "Ozan string_node = #{string_node.to_s}"
				doc.root.add_child string_node
			end
		end
		File.write(file_name, doc.to_xml)
	end

end

class StringArrayTranslator < Translator
	attr_reader :item_type, :docs_names, :docs
	def initialize(input_language)
		super(input_language)
		@item_type = "string-array"
		@docs = ["strings.xml", "arrays.xml", "cm_strings.xml", "cm_arrays.xml"]
	end

	def prepare_english_docs
		super(@docs)
	end

	def prepare_to_be_translated_lang_docs
		super(@docs)
	end

	def find_items_exist_in_to_be_translated_lang
		super(prepare_to_be_translated_lang_docs, @item_type)
	end

	def find_missing_items
		super(prepare_english_docs, find_items_exist_in_to_be_translated_lang, @item_type)
	end

	def write_found_items_to_excel_file
		different_items = find_missing_items
		p = Axlsx::Package.new
		wb = p.workbook #Create excel sheet
		wb.add_worksheet(:name => "Basic Worksheet") do |sheet|
	   		sheet.add_row ["Id", "English", "#{@input_language.upcase}"]
	   			different_items.each do |key,value| #Write all key,value pairs one by one A column -> String, B column -> Value
	        		#print "Key is = #{key} , value is = #{value}"
							#puts "id is = #{key} values is = #{value}"
							id = key
							englishVal = value
	   					sheet.add_row [id, englishVal]
	   		end
		end
		p.serialize("EnglishTo#{@input_language}translation#{@item_type}s.xls") #Have to save as xls , otherwise spreadsheet gem cannot read it correctly
		puts "EnglishTo#{@input_language}translation#{@item_type}s.xls created"
	end

	def import_found_items_from_excel_file
		puts "Transfer Array Translations started with input_language = #{@input_language} and item_type = #{@item_type}"
		Spreadsheet.client_encoding = 'UTF-8'
		begin
			#puts "EnglishTo#{input_language}translation#{item_type}s.xls"
			book = Spreadsheet.open("EnglishTo#{@input_language}translation#{@item_type}s.xls")
			file_name = "values-#{@input_language}/arrays.xml"
			#puts "book created"
			xml_file = File.read("values-#{@input_language}/arrays.xml")
			#puts "xml_file ok"
			doc = Nokogiri::XML(xml_file)
		rescue
			raise "File Not Found, Create file or give permissions"
		end
		sheet = book.worksheet 0
		sheet.each 1 do |row|
			unless row[2].nil?
				string_array = Nokogiri::XML::Node.new "#{@item_type}", doc
				#string_array.content = row[2]
				string_array["name"] = row[0]
				#child = Nokogiri::XML::Node.new "item" ,doc
				child_items = row[2].split(",")
				child_items.each do |child_item|
					#print "Child is = #{child_item}"
					child = Nokogiri::XML::Node.new "item" ,doc
					child.content = child_item
					string_array.add_child(child)
				end
				doc.root.add_child string_array
			end
		end
		File.write(file_name, doc.to_xml)
	end

end



class TranslatorFactory
	def self.get_translator(input_language, item_type)
		case item_type
		when "string" then StringTranslator.new(input_language)
		when "string-array" then StringArrayTranslator.new(input_language)
		end
	end
end

class TranslatorUtils

	def self.is_item_suitable_to_add_missing_list(node, found_items, missing_item_pairs)
		 return ("false" != node["translatable"].to_s &&
							"tablet" != node["product"] &&
							!found_items.include?(node["name"]) &&
							!missing_item_pairs.include?(node["name"]) &&
							!node.text.start_with?('@'))
	end

	def self.is_item_suitable_to_add_founded_list(node)
		return ("false" != node["translatable"].to_s &&
					 "tablet" != node["product"] &&
					 !node.text.start_with?("@"))
	end

end

=begin
def finder_controller(item_type, input_language)
		if item_type == "string"
			english_docs = prepare_single_item_en_docs
			input_language_docs = prepare_single_item_input_language_docs(input_language)
			strings_exists_in_input_language = iterate_over_xml_doc_for_items(item_type, input_language_docs)
			strings_exists_only_in_english = find_missing_elements_for_selected_item(item_type, strings_exists_in_input_language, english_docs)
			write_found_item_pairs_to_excel_file(input_language, strings_exists_only_in_english, item_type)
		elsif item_type == "string-array"
			eng_docs = prepare_multiple_item_en_docs
			input_language_docs = prepare_multiple_item_input_language_docs(input_language)
			arrays_exists_in_input_language = iterate_over_xml_doc_for_items(item_type, input_language_docs)
			arrays_exists_only_in_english = find_missing_elements_for_arrays_items(item_type, arrays_exists_in_input_language, eng_docs)
			write_found_arrays_to_excel_file(input_language, arrays_exists_only_in_english, item_type)
		end
end
=end
##################### LEGACY CODE PART #############################
##### START SINGLE ITEMS --> String Integer  <----  ################
=begin
def prepare_single_item_en_docs
	file_names = ["values/strings.xml", "values/cm_strings.xml", "values/qtistrings.xml"]
	files = []
	file_names.each() do | file_name |
		begin
			files << Nokogiri::XML(File.open(file_name))
			puts "File #{file_name} added"
		rescue
			puts "Couldn't find = #{file_name}"
		end
	end
	files.select{ |doc| !doc.nil?}
end

def prepare_single_item_input_language_docs(input_language)
	file_names = ["strings.xml", "cm_strings.xml", "qtistrings.xml"]
	file_names = file_names.map {|file_name| file_name = "values-#{input_language}" + '/' + file_name}
	files = []
	file_names.each() do | file_name |
		begin
			files << Nokogiri::XML(File.open(file_name))
			puts "File #{file_name} added"
		rescue
			puts "Couldn't find = #{file_name}"
		end
	end
	files.select{ |doc| !doc.nil?}
end

def iterate_over_xml_doc_for_items(item_type, docs)
		found_item_pairs = {}
		docs.each() do |doc|
			doc.xpath("//#{item_type}").each do |node|
					#puts "#{node["name"]} : #{node.text} will be added, node.translatable is -> #{node["translatable"]}"
				if "false" != node["translatable"].to_s && "tablet" != node["product"] && !node.text.start_with?("@")
					#puts "#{doc.class.name}"
					#puts "#{node["name"]} : #{node.text} will be added, node.translatable is -> #{node["translatable"]}"
					#puts "First Letter of #{node.text} -> #{node.text.chars.first}"
					found_item_pairs[node["name"]] = node.text
				end
			end
		end
		found_item_pairs
end
##TODO make this part more generic.
def find_missing_elements_for_selected_item(item_type, found_items , docs)
		missing_item_pairs = {}
		docs.each() do |doc|
			doc.xpath("//#{item_type}").each do |node|
				if "false" != node["translatable"].to_s && "tablet" != node["product"] && !found_items.include?(node["name"]) && !missing_item_pairs.include?(node["name"]) && !node.text.start_with?('@')
					#puts "#{node["name"]} : #{node.text} will be added, node.translatable is ->#{node["translatable"]}"
					#puts "#{node["name"]} : #{node.text} will be added, node.translatable is -> #{node["translatable"]}"
					missing_item_pairs[node["name"]] = node.text
				end
			end
		end
		missing_item_pairs
end

def write_found_item_pairs_to_excel_file(input_language, different_items, item_type)
	p = Axlsx::Package.new
	wb = p.workbook #Create excel sheet
	wb.add_worksheet(:name => "Basic Worksheet") do |sheet|
   		sheet.add_row ["Id", "English", "#{input_language.upcase}"]
   			different_items.each do |key,value| #Write all key,value pairs one by one A column -> String, B column -> Value
        		#print "Key is = #{key} , value is = #{value}"
						id = key
						englishVal = value
   					sheet.add_row [id, englishVal]
   		end
	end
	p.serialize("EnglishTo#{input_language}translation#{item_type}s.xls") #Have to save as xls , otherwise spreadsheet gem cannot read it correctly
	puts "EnglishTo#{input_language}translation#{item_type}s.xls created"
end
#####  END SINGLE ITEMS --> String Integer etc  <----  ########
###############################################################
#####  START MULTIPLE ITEMS --> Arrays  <----  ################

def prepare_multiple_item_en_docs
	file_names = ["strings.xml", "arrays.xml", "cm_strings.xml", "cm_arrays.xml"]
	file_names = file_names.map { |file_name| file_name = 'values/' + file_name }
	files = []
	#puts "File names are = #{file_names.to_s}"
	file_names.each do |file_name|
		begin
		 temp_file = Nokogiri::XML(File.open(file_name))
		 puts "File #{file_name} added"
		 files << temp_file
		rescue
			puts "File #{file_name} couldn't found"
		end
		#puts "File #{file_name} added"
	end
	files.select{ |doc| !doc.nil?}
end

def prepare_multiple_item_input_language_docs(input_language)
	file_names = ["strings.xml", "arrays.xml", "cm_strings.xml", "cm_arrays.xml"]
	file_names = file_names.map { |file_name| file_name = "values-#{input_language}" + '/' + file_name }
	files = []
	#puts "File names are = #{file_names.to_s}"
	file_names.each do |file_name|
		begin
		 temp_file = Nokogiri::XML(File.open(file_name))
		 puts "File #{file_name} added"
		 files << temp_file
		rescue
			puts "File #{file_name} couldn't found"
		end
		#puts "File #{file_name} added"
	end
	files.select{ |doc| !doc.nil?}
end


#TODO Encapsulate control part
def find_missing_elements_for_arrays_items(item_type, found_items ,docs)
		missing_item_pairs = {}
		docs.each() do |doc|
			doc.xpath("//#{item_type}").each do |node|
				if "false" != node["translatable"].to_s && "tablet" != node["product"] && !found_items.include?(node["name"]) && !missing_item_pairs.include?(node["name"]) && !node.text.start_with?("@")
					#puts "#{node["name"]} : #{node.text} will be added, node.translatable is ->#{node["translatable"]}"
					#puts "#{node["name"]} : #{node.text} will be added, node.translatable is -> #{node["translatable"]}"
					#puts "Node = #{node} , its class = #{node.class.name}"
					#puts "Looking for #{node["name"]} array:"
					itemList = []
					#puts "Node is = #{node}"
					node.css("item").each do |child|
						break if child.text.start_with?("@")
						#puts "Array Element : #{child.text}"
						itemList << child.text
						#missing_item_pairs[node["name"]] = node.text
					end
					missing_item_pairs[node["name"]] = itemList unless itemList.empty?
				end
			end
		end
		missing_item_pairs
end

def write_found_arrays_to_excel_file(input_language, different_items,item_type)
	p = Axlsx::Package.new
	wb = p.workbook #Create excel sheet
	wb.add_worksheet(:name => "Basic Worksheet") do |sheet|
   		sheet.add_row ["Id", "English", "#{input_language.upcase}"]
   			different_items.each do |key,value| #Write all key,value pairs one by one A column -> String, B column -> Value
        		#print "Key is = #{key} , value is = #{value}"
						#puts "id is = #{key} values is = #{value}"
						id = key
						englishVal = value
   					sheet.add_row [id, englishVal]
   		end
	end
	p.serialize("EnglishTo#{input_language}translation#{item_type}s.xls") #Have to save as xls , otherwise spreadsheet gem cannot read it correctly
	puts "EnglishTo#{input_language}translation#{item_type}s.xls created"
end



##### END MULTIPLE ITEMS --> Arrays <-- #######################
##### START TRANSLATION IMPORTERS  ############################
def transfer_string_translations(input_language)
	puts  "transfer_string_translations started with = #{input_language}"
	Spreadsheet.client_encoding = 'UTF-8'
	begin
		book = Spreadsheet.open("EnglishTo#{input_language}translationstrings.xls")
		file_name = "values-#{input_language}/strings.xml"
		#xml_file = Nokogiri::XML(File.open("values-#{input_language}/strings.xml")
		xml_file = File.read("values-#{input_language}/strings.xml")
		doc = Nokogiri::XML(xml_file)
	rescue SystemCallError
		raise
	end

	#toBeInsertedStrings = {};
	sheet1 = book.worksheet 0
	sheet1.each 1 do |row|
		if row[2] != nil
			string_node = Nokogiri::XML::Node.new "string", doc
			puts string_node
			string_node.content = row[2]
			string_node["name"] = row[0]
			#puts "Ozan string_node = #{string_node.to_s}"
			doc.root.add_child string_node
		end
	end
	File.write(file_name, doc.to_xml)
end

def transfer_array_translations(input_language, item_type)
	puts "Transfer Array Translations started with input_language = #{input_language} and item_type = #{item_type}"
	Spreadsheet.client_encoding = 'UTF-8'
	begin
		#puts "EnglishTo#{input_language}translation#{item_type}s.xls"
		book = Spreadsheet.open("EnglishTo#{input_language}translation#{item_type}s.xls")
		file_name = "values-#{input_language}/arrays.xml"
		#puts "book created"
		xml_file = File.read("values-#{input_language}/arrays.xml")
		#puts "xml_file ok"
		doc = Nokogiri::XML(xml_file)
	rescue
		raise "File Not Found, Create file or give permissions"
	end
	sheet = book.worksheet 0
	sheet.each 1 do |row|
		unless row[2].nil?
			string_array = Nokogiri::XML::Node.new "string-array", doc
			#string_array.content = row[2]
			string_array["name"] = row[0]
			#child = Nokogiri::XML::Node.new "item" ,doc
			child_items = row[2].split(",")
			child_items.each do |child_item|
				#print "Child is = #{child_item}"
				child = Nokogiri::XML::Node.new "item" ,doc
				child.content = child_item
				string_array.add_child(child)
			end
			#puts "Ozan = #{string_array}"
			#string_array = row[2] ##TODO fix it to 2 before use in production
			#string_array = normalize_array(string_array)
			#print "string-array name = #{string_array_name}, array values = #{string_array}"
			doc.root.add_child string_array
		end
	end
	File.write(file_name, doc.to_xml)
end

#def normalize_array(string_array)
	#string_array[1,-1]
#end

def transfer_translations_controller(input_language, item_type)
	puts "putValuesIntoCorrectPlaces Started with input_language = #{input_language} and item_type = #{item_type}"
	if item_type == "string"
		transfer_string_translations(input_language)
	elsif item_type == "string-array"
		transfer_array_translations(input_language, item_type)
	else
		puts "Unsupported item_type = #{item_type}"
	end
	#transfer_translations(input_language) if item_type == "string"
	#transfer_array_translations(input_language, item_type) if item_type != "string-array"
end


def find_not_translated_strings(input_language, item_type)
	puts "Looking for differences between EN - #{input_language.upcase}"
	finder_controller(item_type, input_language)
end

###### END TRANSLATION IMPORTERS #########
###### MAIN ##########
#TODO Do refactoring here
if(ARGV.first == "diff")
	find_not_translated_strings(ARGV[1], ARGV[2])
elsif(ARGV.first == "transfer")
	transfer_translations_controller(ARGV[1], ARGV[2])
elsif(ARGV.first == "all")
	#find_not_translated_strings(ARGV[1],"string")
	#find_not_translated_strings(ARGV[1],"string-array")
elsif(ARGV.first == "help")
	puts "diff -> to find differences between two files , take two params language and element  ex StringParser.rb diff tr string"
	puts "transfer to import translations from excel file ex StringParser.rb transfer tr string"
end
=end
##### OOP MAIN ####
translator = TranslatorFactory.get_translator(ARGV[1], ARGV[2])
if(ARGV.first == "diff")
	translator.translate
elsif(ARGV.first == "transfer")
	translator.transfer
elsif(ARGV.first == "help")
	puts "diff -> to find differences between two files , take two params language and element  ex StringParser diff tr string"
	puts "transfer to import translations from excel file ex StringParser.rb transfer tr string"
end
