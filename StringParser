#!/usr/bin/env ruby
require 'nokogiri'
require 'axlsx'
require 'spreadsheet'
# author : Ozan Alpay
# email : ozanalpay at yandex dot com dot tr or ozan dot alpay at vestel dot com dot tr
# modification dates : [27/02/2017 , 28/02/2017, 01/03/2017, 03/03/2017] After that started to use Git VCS
# company : Vestel Electronics


# This function find differences between two xml files string elements for ex:
# If values/strings.xml has 30 string,value keys whereas values-nl/strings.xml has only 15 -> That means you haven't translated 15 strings
# It will find them , at write their value to xls values according to their id , and value
def finder_controller(item_type, input_language)
		if item_type == "string"
			english_docs = prepare_single_item_en_docs
			input_language_docs = prepare_single_item_input_language_docs(input_language)
			strings_exists_in_input_language = iterate_over_xml_doc_for_items(item_type, input_language_docs)
			strings_exists_only_in_english = find_missing_elements_for_selected_item(item_type, strings_exists_in_input_language, english_docs)
			write_found_item_pairs_to_excel_file(input_language, strings_exists_only_in_english, item_type)
		elsif item_type == "string-array"
			eng_docs = prepare_multiple_item_en_docs
			input_language_docs = prepare_multiple_item_input_language_docs(input_language)
			arrays_exists_in_input_language = iterate_over_xml_doc_for_items(item_type, input_language_docs)
			arrays_exists_only_in_english = find_missing_elements_for_arrays_items(item_type, arrays_exists_in_input_language, eng_docs)
			write_found_arrays_to_excel_file(input_language, arrays_exists_only_in_english, item_type)
		end
end



##### START SINGLE ITEMS --> String Integer  <----  ################
def prepare_single_item_en_docs
	file_names = ["values/strings.xml", "values/cm_strings.xml", "values/qtistrings.xml"]
	files = []
	file_names.each() do | file_name |
		begin
			files << Nokogiri::XML(File.open(file_name))
			puts "File #{file_name} added"
		rescue
			puts "Couldn't find = #{file_name}"
		end
	end
	files.select{ |doc| !doc.nil?}
end

def prepare_single_item_input_language_docs(input_language)
	file_names = ["strings.xml", "cm_strings.xml", "qtistrings.xml"]
	file_names = file_names.map {|file_name| file_name = "values-#{input_language}" + '/' + file_name}
	files = []
	file_names.each() do | file_name |
		begin
			files << Nokogiri::XML(File.open(file_name))
			puts "File #{file_name} added"
		rescue
			puts "Couldn't find = #{file_name}"
		end
	end
	files.select{ |doc| !doc.nil?}
end

def iterate_over_xml_doc_for_items(item_type, docs)
		found_item_pairs = {}
		docs.each() do |doc|
			doc.xpath("//#{item_type}").each do |node|
					#puts "#{node["name"]} : #{node.text} will be added, node.translatable is -> #{node["translatable"]}"
				if "false" != node["translatable"].to_s && "tablet" != node["product"] && !node.text.start_with?("@")
					#puts "#{doc.class.name}"
					#puts "#{node["name"]} : #{node.text} will be added, node.translatable is -> #{node["translatable"]}"
					#puts "First Letter of #{node.text} -> #{node.text.chars.first}"
					found_item_pairs[node["name"]] = node.text
				end
			end
		end
		found_item_pairs
end

def find_missing_elements_for_selected_item(item_type, found_items , docs)
		missing_item_pairs = {}
		docs.each() do |doc|
			doc.xpath("//#{item_type}").each do |node|
				if "false" != node["translatable"].to_s && "tablet" != node["product"] && !found_items.include?(node["name"]) && !missing_item_pairs.include?(node["name"]) && !node.text.start_with?('@')
					#puts "#{node["name"]} : #{node.text} will be added, node.translatable is ->#{node["translatable"]}"
					#puts "#{node["name"]} : #{node.text} will be added, node.translatable is -> #{node["translatable"]}"
					missing_item_pairs[node["name"]] = node.text
				end
			end
		end
		missing_item_pairs
end

def write_found_item_pairs_to_excel_file(input_language, different_items, item_type)
	p = Axlsx::Package.new
	wb = p.workbook #Create excel sheet
	wb.add_worksheet(:name => "Basic Worksheet") do |sheet|
   		sheet.add_row ["Id", "English", "#{input_language.upcase}"]
   			different_items.each do |key,value| #Write all key,value pairs one by one A column -> String, B column -> Value
        		#print "Key is = #{key} , value is = #{value}"
						id = key
						englishVal = value
   					sheet.add_row [id, englishVal]
   		end
	end
	p.serialize("EnglishTo#{input_language}translation#{item_type}s.xls") #Have to save as xls , otherwise spreadsheet gem cannot read it correctly
	puts "EnglishTo#{input_language}translation#{item_type}s.xls created"
end
#####  END SINGLE ITEMS --> String Integer etc  <----  ########
###############################################################
#####  START MULTIPLE ITEMS --> Arrays  <----  ################

def prepare_multiple_item_en_docs
	file_names = ["strings.xml", "arrays.xml", "cm_strings.xml", "cm_arrays.xml"]
	file_names = file_names.map { |file_name| file_name = 'values/' + file_name }
	files = []
	#puts "File names are = #{file_names.to_s}"
	file_names.each do |file_name|
		begin
		 temp_file = Nokogiri::XML(File.open(file_name))
		 puts "File #{file_name} added"
		 files << temp_file
		rescue
			puts "File #{file_name} couldn't found"
		end
		#puts "File #{file_name} added"
	end
	files.select{ |doc| !doc.nil?}
end

def prepare_multiple_item_input_language_docs(input_language)
	file_names = ["strings.xml", "arrays.xml", "cm_strings.xml", "cm_arrays.xml"]
	file_names = file_names.map { |file_name| file_name = "values-#{input_language}" + '/' + file_name }
	files = []
	#puts "File names are = #{file_names.to_s}"
	file_names.each do |file_name|
		begin
		 temp_file = Nokogiri::XML(File.open(file_name))
		 puts "File #{file_name} added"
		 files << temp_file
		rescue
			puts "File #{file_name} couldn't found"
		end
		#puts "File #{file_name} added"
	end
	files.select{ |doc| !doc.nil?}
end



def find_missing_elements_for_arrays_items(item_type, found_items ,docs)
		missing_item_pairs = {}
		docs.each() do |doc|
			doc.xpath("//#{item_type}").each do |node|
				if "false" != node["translatable"].to_s && "tablet" != node["product"] && !found_items.include?(node["name"]) && !missing_item_pairs.include?(node["name"]) && !node.text.start_with?("@")
					#puts "#{node["name"]} : #{node.text} will be added, node.translatable is ->#{node["translatable"]}"
					#puts "#{node["name"]} : #{node.text} will be added, node.translatable is -> #{node["translatable"]}"
					#puts "Node = #{node} , its class = #{node.class.name}"
					#puts "Looking for #{node["name"]} array:"
					itemList = []
					#puts "Node is = #{node}"
					node.css("item").each do |child|
						break if child.text.start_with?("@")
						#puts "Array Element : #{child.text}"
						itemList << child.text
						#missing_item_pairs[node["name"]] = node.text
					end
					missing_item_pairs[node["name"]] = itemList unless itemList.empty?
				end
			end
		end
		missing_item_pairs
end

def write_found_arrays_to_excel_file(input_language, different_items,item_type)
	p = Axlsx::Package.new
	wb = p.workbook #Create excel sheet
	wb.add_worksheet(:name => "Basic Worksheet") do |sheet|
   		sheet.add_row ["Id", "English", "#{input_language.upcase}"]
   			different_items.each do |key,value| #Write all key,value pairs one by one A column -> String, B column -> Value
        		#print "Key is = #{key} , value is = #{value}"
						#puts "id is = #{key} values is = #{value}"
						id = key
						englishVal = value
   					sheet.add_row [id, englishVal]
   		end
	end
	p.serialize("EnglishTo#{input_language}translation#{item_type}s.xls") #Have to save as xls , otherwise spreadsheet gem cannot read it correctly
	puts "EnglishTo#{input_language}translation#{item_type}s.xls created"
end



##### END MULTIPLE ITEMS --> Arrays <-- #######################

def transfer_string_translations(input_language)
	puts  "transfer_string_translations started with = #{input_language}"
	Spreadsheet.client_encoding = 'UTF-8'
	begin
		book = Spreadsheet.open("EnglishTo#{input_language}translationstrings.xls")
		file_name = "values-#{input_language}/strings.xml"
		#xml_file = Nokogiri::XML(File.open("values-#{input_language}/strings.xml")
		xml_file = File.read("values-#{input_language}/strings.xml")
		doc = Nokogiri::XML(xml_file)
	rescue SystemCallError
		raise
	end

	#toBeInsertedStrings = {};
	sheet1 = book.worksheet 0
	sheet1.each 1 do |row|
		if row[2] != nil
			string_node = Nokogiri::XML::Node.new "string", doc
			puts string_node
			string_node.content = row[2]
			string_node["name"] = row[0]
			#puts "Ozan string_node = #{string_node.to_s}"
			doc.root.add_child string_node
		end
	end
	File.write(file_name, doc.to_xml)
end

def transfer_array_translations(input_language, item_type)
	puts "Transfer Array Translations started with input_language = #{input_language} and item_type = #{item_type}"
	Spreadsheet.client_encoding = 'UTF-8'
	begin
		#puts "EnglishTo#{input_language}translation#{item_type}s.xls"
		book = Spreadsheet.open("EnglishTo#{input_language}translation#{item_type}s.xls")
		file_name = "values-#{input_language}/arrays.xml"
		#puts "book created"
		xml_file = File.read("values-#{input_language}/arrays.xml")
		#puts "xml_file ok"
		doc = Nokogiri::XML(xml_file)
	rescue
		raise "File Not Found, Create file or give permissions"
	end
	sheet = book.worksheet 0
	sheet.each 1 do |row|
		unless row[2].nil?
			string_array = Nokogiri::XML::Node.new "string-array", doc
			#string_array.content = row[2]
			string_array["name"] = row[0]
			#child = Nokogiri::XML::Node.new "item" ,doc
			child_items = row[2].split(",")
			child_items.each do |child_item|
				#print "Child is = #{child_item}"
				child = Nokogiri::XML::Node.new "item" ,doc
				child.content = child_item
				string_array.add_child(child)
			end
			#puts "Ozan = #{string_array}"
			#string_array = row[2] ##TODO fix it to 2 before use in production
			#string_array = normalize_array(string_array)
			#print "string-array name = #{string_array_name}, array values = #{string_array}"
			doc.root.add_child string_array
		end
	end
	File.write(file_name, doc.to_xml)
end

#def normalize_array(string_array)
	#string_array[1,-1]
#end

def transfer_translations_controller(input_language, item_type)
	puts "putValuesIntoCorrectPlaces Started with input_language = #{input_language} and item_type = #{item_type}"
	if item_type == "string"
		transfer_string_translations(input_language)
	elsif item_type == "string-array"
		transfer_array_translations(input_language, item_type)
	else
		puts "Unsupported item_type = #{item_type}"
	end
	#transfer_translations(input_language) if item_type == "string"
	#transfer_array_translations(input_language, item_type) if item_type != "string-array"
end


def find_not_translated_strings(input_language, item_type)
	puts "Looking for differences between EN - #{input_language.upcase}"
	finder_controller(item_type, input_language)
end

#MAIN

if(ARGV.first == "diff")
	find_not_translated_strings(ARGV[1], ARGV[2])
elsif(ARGV.first == "transfer")
	transfer_translations_controller(ARGV[1], ARGV[2])
elsif(ARGV.first == "all")
	#find_not_translated_strings(ARGV[1],"string")
	#find_not_translated_strings(ARGV[1],"string-array")
elsif(ARGV.first == "help")
	puts "diff -> to find differences between two files , take two params language and element  ex StringParser.rb diff tr string"
	puts "transfer to import translations from excel file ex StringParser.rb transfer tr string"
end
